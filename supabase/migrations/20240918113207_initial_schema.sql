SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

CREATE EXTENSION IF NOT EXISTS "pg_net" WITH SCHEMA "extensions";
CREATE EXTENSION IF NOT EXISTS "pgsodium" WITH SCHEMA "pgsodium";

COMMENT ON SCHEMA "public" IS 'standard public schema';
CREATE EXTENSION IF NOT EXISTS "pg_graphql" WITH SCHEMA "graphql";

CREATE EXTENSION IF NOT EXISTS "pg_stat_statements" WITH SCHEMA "extensions";
CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA "extensions";
CREATE EXTENSION IF NOT EXISTS "pgjwt" WITH SCHEMA "extensions";
CREATE EXTENSION IF NOT EXISTS "supabase_vault" WITH SCHEMA "vault";
CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA "extensions";

CREATE TYPE "public"."key_mode" AS ENUM (
    'read',
    'write',
    'all',
    'upload'
);

ALTER TYPE "public"."key_mode" OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."is_allowed_apikey"("apikey" "text", "keymode" "public"."key_mode"[]) RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$Begin
  RETURN (SELECT EXISTS (SELECT 1
  FROM api_auth_tokens
  WHERE token=uuid(apikey)
  AND mode=ANY(keymode)));
End;$$;

ALTER FUNCTION "public"."is_allowed_apikey"("apikey" "text", "keymode" "public"."key_mode"[]) OWNER TO "postgres";

SET default_tablespace = '';
SET default_table_access_method = "heap";

CREATE TABLE IF NOT EXISTS "public"."api_auth_tokens" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "mode" "public"."key_mode" DEFAULT 'read'::"public"."key_mode" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "token" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL
);

ALTER TABLE "public"."api_auth_tokens" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."blocks" (
    "block_number" bigint NOT NULL,
    "timestamp" timestamp without time zone NOT NULL,
    "gas_used" bigint NOT NULL,
    "transaction_count" integer NOT NULL
);

ALTER TABLE "public"."blocks" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."proofs" (
    "proof_id" integer NOT NULL,
    "block_number" bigint NOT NULL,
    "proof" "bytea" NOT NULL,
    "proof_status" "text" NOT NULL,
    "prover_machine_id" integer,
    "prover_duration" interval,
    "proving_cost" numeric(10,2),
    "proving_cycles" bigint,
    "submission_time" timestamp with time zone DEFAULT "now"(),
    "user_id" "uuid" NOT NULL,
    CONSTRAINT "proofs_proof_status_check" CHECK (("proof_status" = ANY (ARRAY['queued'::"text", 'proving'::"text", 'proved'::"text"])))
);

ALTER TABLE "public"."proofs" OWNER TO "postgres";

ALTER TABLE "public"."proofs" ALTER COLUMN "proof_id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."proofs_proof_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

CREATE TABLE IF NOT EXISTS "public"."prover_machines" (
    "machine_id" integer NOT NULL,
    "machine_name" "text" NOT NULL,
    "user_id" "uuid"
);

ALTER TABLE "public"."prover_machines" OWNER TO "postgres";

ALTER TABLE "public"."prover_machines" ALTER COLUMN "machine_id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."prover_machines_machine_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

CREATE TABLE IF NOT EXISTS "public"."recursive_root_proofs" (
    "root_proof_id" integer NOT NULL,
    "block_number" bigint,
    "root_proof" "bytea" NOT NULL,
    "root_proof_size" bigint NOT NULL,
    "total_proof_size" bigint NOT NULL,
    "user_id" "uuid"
);

ALTER TABLE "public"."recursive_root_proofs" OWNER TO "postgres";

ALTER TABLE "public"."recursive_root_proofs" ALTER COLUMN "root_proof_id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."recursive_root_proofs_root_proof_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);
CREATE TABLE IF NOT EXISTS "public"."teams" (
    "team_id" integer NOT NULL,
    "team_name" "text" NOT NULL,
    "user_id" "uuid"
);

ALTER TABLE "public"."teams" OWNER TO "postgres";

ALTER TABLE "public"."teams" ALTER COLUMN "team_id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."teams_team_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);
ALTER TABLE ONLY "public"."api_auth_tokens"
    ADD CONSTRAINT "api_auth_tokens_pkey" PRIMARY KEY ("id");
ALTER TABLE ONLY "public"."api_auth_tokens"
    ADD CONSTRAINT "api_auth_tokens_token_key" UNIQUE ("token");
ALTER TABLE ONLY "public"."blocks"
    ADD CONSTRAINT "blocks_pkey" PRIMARY KEY ("block_number");
ALTER TABLE ONLY "public"."proofs"
    ADD CONSTRAINT "proofs_pkey" PRIMARY KEY ("proof_id");
ALTER TABLE ONLY "public"."prover_machines"
    ADD CONSTRAINT "prover_machines_pkey" PRIMARY KEY ("machine_id");
ALTER TABLE ONLY "public"."recursive_root_proofs"
    ADD CONSTRAINT "recursive_root_proofs_pkey" PRIMARY KEY ("root_proof_id");
ALTER TABLE ONLY "public"."teams"
    ADD CONSTRAINT "teams_pkey" PRIMARY KEY ("team_id");
ALTER TABLE ONLY "public"."api_auth_tokens"
    ADD CONSTRAINT "api_auth_tokens_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON UPDATE CASCADE ON DELETE CASCADE;
ALTER TABLE ONLY "public"."proofs"
    ADD CONSTRAINT "proofs_block_number_fkey" FOREIGN KEY ("block_number") REFERENCES "public"."blocks"("block_number");
ALTER TABLE ONLY "public"."proofs"
    ADD CONSTRAINT "proofs_prover_machine_id_fkey" FOREIGN KEY ("prover_machine_id") REFERENCES "public"."prover_machines"("machine_id");
ALTER TABLE ONLY "public"."proofs"
    ADD CONSTRAINT "proofs_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;
ALTER TABLE ONLY "public"."prover_machines"
    ADD CONSTRAINT "prover_machines_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;
ALTER TABLE ONLY "public"."recursive_root_proofs"
    ADD CONSTRAINT "recursive_root_proofs_block_number_fkey" FOREIGN KEY ("block_number") REFERENCES "public"."blocks"("block_number");
ALTER TABLE ONLY "public"."recursive_root_proofs"
    ADD CONSTRAINT "recursive_root_proofs_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");
ALTER TABLE ONLY "public"."teams"
    ADD CONSTRAINT "teams_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;
    
CREATE POLICY "Allow users to see API token entries they own" ON "public"."api_auth_tokens" FOR SELECT TO "anon" USING ("public"."is_allowed_apikey"((("current_setting"('request.headers'::"text", true))::"json" ->> 'apikey'::"text"), '{all,read}'::"public"."key_mode"[]));
CREATE POLICY "Enable insert for authenticated users only" ON "public"."blocks" FOR INSERT TO "authenticated" WITH CHECK (true);
CREATE POLICY "Enable insert for users with an api key" ON "public"."proofs" FOR INSERT WITH CHECK ("public"."is_allowed_apikey"((("current_setting"('request.headers'::"text", true))::"json" ->> 'apikey'::"text"), '{all,write}'::"public"."key_mode"[]));
CREATE POLICY "Enable read access for all users" ON "public"."blocks" FOR SELECT USING (true);
CREATE POLICY "Enable read access for all users" ON "public"."proofs" FOR SELECT USING (true);
CREATE POLICY "Enable read access for all users" ON "public"."prover_machines" FOR SELECT USING (true);
CREATE POLICY "Enable read access for all users" ON "public"."recursive_root_proofs" FOR SELECT USING (true);
CREATE POLICY "Enable read access for all users" ON "public"."teams" FOR SELECT USING (true);

ALTER TABLE "public"."api_auth_tokens" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."blocks" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."proofs" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."prover_machines" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."recursive_root_proofs" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."teams" ENABLE ROW LEVEL SECURITY;

ALTER PUBLICATION "supabase_realtime" OWNER TO "postgres";
GRANT USAGE ON SCHEMA "public" TO "postgres";
GRANT USAGE ON SCHEMA "public" TO "anon";
GRANT USAGE ON SCHEMA "public" TO "authenticated";
GRANT USAGE ON SCHEMA "public" TO "service_role";

GRANT ALL ON FUNCTION "public"."is_allowed_apikey"("apikey" "text", "keymode" "public"."key_mode"[]) TO "anon";
GRANT ALL ON FUNCTION "public"."is_allowed_apikey"("apikey" "text", "keymode" "public"."key_mode"[]) TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_allowed_apikey"("apikey" "text", "keymode" "public"."key_mode"[]) TO "service_role";
GRANT ALL ON TABLE "public"."api_auth_tokens" TO "anon";
GRANT ALL ON TABLE "public"."api_auth_tokens" TO "authenticated";
GRANT ALL ON TABLE "public"."api_auth_tokens" TO "service_role";
GRANT ALL ON TABLE "public"."blocks" TO "anon";
GRANT ALL ON TABLE "public"."blocks" TO "authenticated";
GRANT ALL ON TABLE "public"."blocks" TO "service_role";
GRANT ALL ON TABLE "public"."proofs" TO "anon";
GRANT ALL ON TABLE "public"."proofs" TO "authenticated";
GRANT ALL ON TABLE "public"."proofs" TO "service_role";
GRANT ALL ON SEQUENCE "public"."proofs_proof_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."proofs_proof_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."proofs_proof_id_seq" TO "service_role";
GRANT ALL ON TABLE "public"."prover_machines" TO "anon";
GRANT ALL ON TABLE "public"."prover_machines" TO "authenticated";
GRANT ALL ON TABLE "public"."prover_machines" TO "service_role";
GRANT ALL ON SEQUENCE "public"."prover_machines_machine_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."prover_machines_machine_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."prover_machines_machine_id_seq" TO "service_role";
GRANT ALL ON TABLE "public"."recursive_root_proofs" TO "anon";
GRANT ALL ON TABLE "public"."recursive_root_proofs" TO "authenticated";
GRANT ALL ON TABLE "public"."recursive_root_proofs" TO "service_role";
GRANT ALL ON SEQUENCE "public"."recursive_root_proofs_root_proof_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."recursive_root_proofs_root_proof_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."recursive_root_proofs_root_proof_id_seq" TO "service_role";
GRANT ALL ON TABLE "public"."teams" TO "anon";
GRANT ALL ON TABLE "public"."teams" TO "authenticated";
GRANT ALL ON TABLE "public"."teams" TO "service_role";
GRANT ALL ON SEQUENCE "public"."teams_team_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."teams_team_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."teams_team_id_seq" TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "service_role";

RESET ALL;
